---
title: "Lista 1"
subtitle: "Modelagem com Apoio Computacional"
author: "Tailine J. S. Nonato"
date: today
date-format: long
format: pdf
---

# Carregamento dos dados

```{r}
#| label: data
fatigue_df <- data.frame(work_MJ_m3 = c(11.5,13.0,14.3,15.6,16.0,17.3,19.3,
21.1,21.5,22.6,22.6,24.0,24.0,24.6,25.2,25.5,26.3,27.9,28.3,28.4,28.6,30.9,
31.9,34.5,40.1,40.1,43.0,44.1,46.5,47.3,48.7,52.9,56.6,59.9,60.2,60.3,60.5,
62.1,62.8,66.5,67.0,67.1,67.9,68.8,75.4,100.5),life_cycles = c(3280,5046,
1563,4707,977,2834,2266,2208,1040,700,1583,482, 804,1093,1125,884,1300,
852,580,1066,1114,386,745,736, 750,316,456,552,355,242,190,127,185,255,
195, 283,212,327,373,125,187,135,245,137,200,190))

head(fatigue_df)
```

# Ajuste do modelo com base na moda

```{r}
#| label: model_moda
mle_moda_bs <- function(x, t) {
  x <- as.matrix(x)
  t <- as.matrix(t)

  fit <- lm.fit(x, log(t)) 
  beta <- c(fit$coef)
  
  k <- length(beta)
  n <- length(t)

  mu_init <- x %*% beta
  alpha <- sqrt((4/n)*sum((sinh((log(t) - mu_init)/2))^2))
  
  phi_init <- alpha^2 #chute inicial
  
  thetaStar <- c(beta, phi_init)
  
  loglik_moda <- function(par) {
    log_moda_Y <- x %*% par[1:k] 
    phi_param <- par[k+1]
    if (phi_param <= 0 || phi_param >= 1) {
      return(NA)}

    alpha_art <- sqrt(phi_param) #proposta do artifo
    beta_art <- exp(log_moda_Y) / (1 - phi_param) #proposta do artigo

    #pdf da distribuição log-BS
    z <- (sqrt(t/beta_art) - sqrt(beta_art/t))/alpha_art
    pdf_bs <- (1/(alpha_art*sqrt(t)))*(sqrt(t/beta_art) + 
    sqrt(beta_art/t))*dnorm(z)
    pdf_bs[pdf_bs <= 0] <- .Machine$double.xmin 
    #substitui valor menor ou igual a 0 por um número muito pequeno
    
    #log-verossimilhança
    l_i <- log(pdf_bs)
    if (any(!is.finite(l_i))) {
      return(.Machine$double.xmax)} 
      #retorna um valor muito grande se algum log for infinito
    
    #verossimilhança total (loglik-plus)
    return(-sum(l_i))}

  est <- optim(
    par = thetaStar, 
    fn = loglik_moda,
    method = "BFGS", 
    hessian = TRUE,
    control = list(maxit = 2000, reltol = 1e-12))
  
  if (est$conv != 0) {
    warning("FUNCTION DID NOT CONVERGE!")}
  
  coef <- (est$par)[1:k]
  phi_est <- est$par[k + 1] 

  moda_hat_log <- x %*% coef
  moda_hat <- exp(moda_hat_log)
  
  SHess = solve(est$hessian)
  SE = sqrt(diag(SHess))
  
  tval = est$par / SE
  matcoef = cbind(est$par, SE, tval, 2 * (1 - pnorm(abs(tval))))
  
  AIC <- 2 * est$value + 2 * (k + 1)
  BIC <- 2 * est$value + (k + 1) * log(n)
  
  result <- list(
    phiHat = phi_est,
    betaHat_log_moda = coef,
    modaHat = moda_hat,
    AIC = AIC,
    BIC = BIC,
    matcoef = matcoef)

  return(result)}
```

## Estimativas do modelo

```{r}
#| label: fit_moda_bs

Zx <- model.matrix(~ log(fatigue_df$work_MJ_m3)) 
Zy <- fatigue_df$life_cycles 

fit_moda <- mle_moda_bs(x = Zx , t = Zy)
fit_moda$matcoef

plot(log(fatigue_df$work_MJ_m3), Zy, 
     main = "Dados observados e moda ajustada",
     xlab = "Log(Work MJ/m3)", ylab = "Life Cycles")
points(log(fatigue_df$work_MJ_m3), fit_moda$modaHat, 
       col = "red", pch = 16, cex = 0.8)
legend("topright", 
    legend = c("Dados observados", "Moda ajustada"), 
    col = c("black", "red"), pch = c(1, 16))
```

## Verificação de ajuste do modelo

```{r}
#| label: residuos_moda

S_bs_moda <- function(y, mu, phi) {
  alpha <- sqrt(phi)
  beta  <- mu / (1 - phi)
  xi <- (sqrt(y/beta) - sqrt(beta/y)) / alpha
  S <- 1 - pnorm(xi)
  return(S)}

residuos_bs_moda <- function(y, mu_hat, phi_hat) {
  S <- S_bs_moda(y, mu_hat, phi_hat)
  r_cox <- -log(S)      
  r_quant <- qnorm(S)    
  list(coxsnell = r_cox, quantile = r_quant)}

res_moda <- residuos_bs_moda(
  y = fatigue_df$life_cycles,
  mu_hat = fit_moda$modaHat,
  phi_hat = fit_moda$phiHat)

# QQ plot
a <- ppoints(2000)
QGG <- qexp(a)
qqplot(QGG, res_moda$coxsnell,
       xlab = "Quantis Exp(1)", ylab = "Quantis amostrais",
       main = "QQ-plot Resíduos")
abline(0,1,col="red")

# QQ plot quantílicos
qqnorm(res_moda$quantile); qqline(res_moda$quantile, col=2)
```

Os dois gráficos são bem similares aos gráficos para o modelo baseado na média. Indicando também adequação do modelo com base na moda.

# Comparação dos modelos

## Moda
```{r}
#| label: model_mode
#| echo: false
fit_moda$matcoef
```

## Média
```{r}
#| label: model_mean
#| echo: false
mle_unc <- function(x, t, v, kernel = "normal") {
    x <- as.matrix(x)
    t <- as.matrix(t)
    y <- as.matrix(log(t))
    fit <- lm.fit(x, y)
    beta <- c(fit$coef)
    k <- length(beta)
    n <- length(y)
    mu <- x %*% beta
    alpha <- sqrt((4 / n ) * sum((sinh((y - mu) / 2)) ^ 2))
    thetaStar <- c(beta,alpha)
    loglik <- function(par){
        z1 <- par[1:k]
        z2 <- par[k + 1]
        mu <- (x %*% z1)
        xi1 <- (2 / z2) * cosh((y - mu) / 2)
        xi2 <- (2 / z2) * sinh((y - mu) / 2)
        g <- switch(kernel,
            "normal" = exp(-(xi2 ^ 2) / 2),
            "t" = (v + (xi2 ^ 2)) ^ (-(v + 1) / 2)
        )
        const <- switch(kernel,
            "normal" = 1 / (sqrt(2 * pi)),
            "t" = (gamma((v + 1) / 2) * v ^ (v / 2)) /
                (sqrt(pi) * gamma(v / 2))
        )
        result <- switch(kernel,
            "normal" = sum( log(const / 2) + log(xi1) + log(g) ) ,
            "t" = sum(log(const / 2) + log(xi1) + log(g) )
        )
        return(-result)
    }
    loglikplus <- function(par){
        z1 <- par[1:k]
        z2 <- par[k + 1]
        mu <- (x %*% z1)
        xi1 <- (2 / z2) * cosh((y - mu) / 2)
        xi2 <- (2 / z2) * sinh((y - mu) / 2)
        result <- log(dnorm(xi2)) + log(xi1/2)
        return(sum(result))
    }
    score <- function(par){
        z1 <-par[1:k]
        z2 <-par[k+1]
        mu <-(x %*% z1)
        xi1 <- (2 / z2) * cosh((y - mu) / 2)
        xi2 <- (2 / z2) * sinh((y - mu) / 2)
        status <- 1
        const <- switch(kernel,
            "normal" = 1 / (sqrt(2 * pi)),
            "t" = (gamma((v + 1.0) / 2) * v ^ (v / 2)) /
                (sqrt(pi) * gamma(v / 2))
        )
        derivativeF <- switch(kernel,
            "normal" = -(const) * xi2 * exp(-(xi2 ^ 2) / 2),
            "t" = -(const) * (v + 1) * xi2 * ((v + (xi2 ^ 2)) ^
                (-(v + 3) /2))
        )
        h <- switch(kernel,
            "normal" = dnorm(xi2) / (1 - pnorm(xi2)),
            "t" = dt(xi2, df = v) / (1 - pt(xi2, df = v))
        )
        wg <- switch(kernel,
            "normal" = -(1 / 2),
            "t" = -(v + 1) / (2 * (v + (xi2 ^ 2)))
        )
        Ubeta <- switch(kernel,
            "normal" = -status * ((2 / (z2 ^ 2)) * sinh(y - mu) * wg +
                (1 / 2) * tanh((y - mu) / 2)) +
                ((1 - status) / 2) * xi1 * h,
            "t" = -status * ((2 / (z2 ^ 2)) * sinh(y - mu) * wg +
                (1 / 2) * tanh((y - mu) / 2)) +
                ((1 - status) / 2) * xi1 * h
        )
        Ualpha <- switch(kernel,
            "normal" = -sum((status / z2) *
                (((xi2 ^ 2) * 2 * wg) + 1) -
                ((1 - status) / z2) * h * xi2),
            "t" = -sum((status / z2) * (((xi2 ^ 2) * 2 * wg) + 1) -
                ((1 - status) / z2) * h * xi2)
        )
        result <- c(t(x) %*% Ubeta, Ualpha)
        return(result)
    }
    # est <- optim(thetaStar, loglik, method = "BFGS", hessian = TRUE)
    est <- optim(thetaStar, loglik, method = "BFGS", hessian = TRUE)
    # control = list(fnscale = -1, maxit = 2000, reltol = 1e-12))
    if(est$conv != 0)
        warning("FUNCTION DID NOT CONVERGE!")
    coef <-(est$par)[1:k]
    alphaest <- est$par[k+1]
    muhat <- x %*% coef
    muhat <- as.vector(muhat)
    etahat <- exp(muhat)
    SHess = solve(est$hessian)
    SE = sqrt(diag(SHess))
    se.coef = SE
    tval = c(coef,alphaest)/se.coef
    matcoef = cbind(c(coef,alphaest), se.coef, tval, 2*(1-pnorm(abs(tval))))
    AIC <- 2 *loglik(c(coef,alphaest)) + 2 * (length(coef) + 1)
    BIC = 2 * loglik(c(coef,alphaest)) + (length(coef) + 1) * log(length(y))
    result <- list(
        alphaHat = alphaest,
        betaHat = coef,
        muHat = muhat,
        AIC = AIC,
        BIC = BIC,
        matcoef = matcoef
    )
    return(result)
}
```


```{r}
#| label: model_mean_estim
#| echo: false

Zx <- model.matrix(~ log(fatigue_df$work_MJ_m3))
Zy <- fatigue_df$life_cycles
fit_logbs1 <- mle_unc (x = Zx , t = Zy , kernel = "normal")
fit_logbs1$matcoef
```