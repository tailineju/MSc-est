---
title: "Projeto - Rascunho"
subtitle: "Modelagem com Apoio Computacional"
author: "Tailine J. S. Nonato"
date: today
date-format: long
format: html
---

# The dataset

Castor seed germination dataset shared by Doctor Liv Soares Severino from Embrapa Algodão. 

Link: <a href="https://doi.org/10.48432/6N3WQA" target="_blank">Castor seed hydration and germination influenced by temperature and puncture</a>

```{r}
#| label: data
#| echo: false

pacman::p_load(tidyverse, knitr, MASS, maxLik, VGAM, gamlss, gamlss.dist, gamlss.add)

theme_article <- function() {
  theme_classic() +
    theme(
      axis.line = element_line(colour = "black"),
      panel.border = element_rect(colour = "black", fill=NA),
      panel.background = element_blank(),
      plot.background = element_blank(),
      axis.ticks = element_line(colour = "black"),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.text = element_text(colour = "black", size=16),
      axis.title = element_text(colour="black", size=18),
    )}

castor <- read.csv2("C:/Users/User/Documents/GitHub/MSc-est/MODELAGEM COM APOIO COMPUTACIONAL/article/castorseed.csv")

#phase="Germinated"
castor <- castor %>%
  filter(phase == "Germinated")

kable(head(castor))
```

# Exploratory Data Analysis (EDA)

```{r}
#| label: histogram

#interesse na variável time

ggplot(castor, aes(x = time)) +
  geom_histogram(bins = 30, fill = "#007937", color="black") +
  labs(title = "Time for germination (Frequency)", x = "Time", y = "Frequency") +
  theme_article()
  #save as png
  ggsave("C:/Users/User/Documents/GitHub/MSc-est/MODELAGEM COM APOIO COMPUTACIONAL/article/img/histogram_frequency.png", width = 8, height = 6)

  # com a densidade

ggplot(castor, aes(x = time)) +
  geom_histogram(aes(y = after_stat(density)), bins = 30, fill = "#007937", color="black") +
  geom_density(color = "red", linewidth = 1.2) +
  labs(title = "Time for germination (Density)", x = "Time", y = "Density") +
  theme_article()
  ggsave("C:/Users/User/Documents/GitHub/MSc-est/MODELAGEM COM APOIO COMPUTACIONAL/article/img/histogram_density.png", width = 8, height = 6)
```


```{r}
#| label: scatter-plots

ggplot(castor, aes(x = time_under_hydration, y = time)) +
  geom_point(color="#007937") +
  labs(
    title = "Scatter Plot with Regression Lines",
    x = "Time under hydration", y = "Time for germination", color = "Puncture") +
  theme_article()
  ggsave("C:/Users/User/Documents/GitHub/MSc-est/MODELAGEM COM APOIO COMPUTACIONAL/article/img/tuh.png", width = 8, height = 6)
```

```{r}
#| label: boxplots

ggplot(castor, aes(x = as.factor(temperature), y = time)) +
  geom_boxplot(fill = "#007937", color = "black") +
  labs(title = "Boxplot of Time by Temperature",
       x = "Temperature (°C)", y = "Time for germination") +
  theme_article()
  ggsave("C:/Users/User/Documents/GitHub/MSc-est/MODELAGEM COM APOIO COMPUTACIONAL/article/img/boxplot_temperature.png", width = 8, height = 6)

ggplot(castor, aes(x = as.factor(puncture), y = time)) +
  geom_boxplot(fill = "#007937", color = "black") +
  labs(title = "Boxplot of Time by Puncture",
       x = "Puncture (Yes/No)", y = "Time for germination") +
  theme_article()
  ggsave("C:/Users/User/Documents/GitHub/MSc-est/MODELAGEM COM APOIO COMPUTACIONAL/article/img/boxplot_puncture.png", width = 8, height = 6)
```

# Fitting a Linear Regression Model based on the Birnbaum-Saunders Distribution

```{r}
# | label: bs-to-gamlss

# authors: Roquim, Fernanda; Ramires, Thiago; et al.
# source: https://ojs.uel.br/revistas/uel/index.php/semexatas/article/view/44417

#----------------------------------------------------------------------------------------
# Utilizando a distribuicao BS em GAMLSS
#----------------------------------------------------------------------------------------
BS <- function(mu.link = "log", sigma.link = "log"){
  mstats <- checklink("mu.link", "BS", substitute(mu.link),
                      c("inverse", "log", "identity", "own"))
  dstats <- checklink("sigma.link", "BS", substitute(sigma.link),
                      c("inverse", "log", "identity", "own"))
  structure(
    list(family = c("BS", "Birnbaum-Saunders"),
         parameters = list(mu=TRUE,sigma=TRUE),
         nopar = 2,
         type = "Continuous",
         mu.link = as.character(substitute(mu.link)),
         sigma.link = as.character(substitute(sigma.link)),
         mu.linkfun = mstats$linkfun,
         sigma.linkfun = dstats$linkfun,
         mu.linkinv = mstats$linkinv,
         sigma.linkinv = dstats$linkinv,
         mu.dr = mstats$mu.eta,
         sigma.dr = dstats$mu.eta,
         
         
         
         dldm = function(y,sigma,mu) 1/(y+mu)-1/(2*mu)-1/(2*sigma^2)*(1/y-y/mu^2),
         dldd = function(y,sigma,mu) 1/sigma^3*(y/mu+mu/y-2)-1/sigma,
         d2ldm2 = function(y,sigma,mu) -(1/(y+mu)-1/(2*mu)-1/(2*sigma^2)*(1/y-y/mu^2))^2,
         d2ldd2 = function(y,sigma,mu) -2/sigma^2,

         d2ldmdd = function(y,sigma,mu){
           nd = gamlss:::numeric.deriv(dBS(y, mu, sigma,log = TRUE), "mu", delta = 1e-04)
           dldm = as.vector(attr(nd, "gradient"))
           nd = gamlss:::numeric.deriv(dBS(y, mu, sigma, log = TRUE), "sigma", delta = 1e-04)
           dldd = as.vector(attr(nd, "gradient"))
           d2ldmdd = -dldm * dldd
           d2ldmdd
         },
         
         
         G.dev.incr = function(y,mu,sigma,...) -2*dBS(y,mu,sigma,log=TRUE),
         rqres = expression(rqres(pfun="pBS", type="Continuous",y=y,mu=mu,sigma=sigma)),
         
         mu.initial = expression({mu <- rep(median(y),length(y))}),
         sigma.initial = expression({ sigma <- rep(1,length(y)) }),
         
         mu.valid = function(mu) all(mu > 0) ,
         sigma.valid = function(sigma) all(sigma > 0),
         y.valid = function(y) all(y > 0)
    ),
    class = c("gamlss.family","family"))
}

#----------------------------------------------------------------------------------------
# fdp da distribuicao BS
dBS<-function(x, mu=1, sigma=1, log=FALSE){
  if (any(mu <= 0)) stop(paste("mu must be positive", "\n", ""))
  if (any(sigma <= 0)) stop(paste("sigma must be positive", "\n", ""))
  if (any(x < 0)) stop(paste("x must be positive", "\n", ""))
  fy <- 1/(2*sigma*sqrt(2*pi*mu))*x^(-3/2)*(x+mu)*exp(-1/(2*sigma^2)*(x/mu+mu/x-2))
  fy
}
#----------------------------------------------------------------------------------------
# fda da distribuicao BS
pBS <- function(q, mu=1, sigma=1, lower.tail = TRUE, log.p = FALSE){
  if (any(mu <= 0)) stop(paste("mu must be positive", "\n", ""))
  if (any(sigma <= 0)) stop(paste("sigma must be positive", "\n", ""))
  if (any(q < 0)) stop(paste("y must be positive", "\n", ""))
  cumulative <- function(x, a, b){
    integration <- integrate(dBS, lower = 0, upper = x, mu = a, sigma = b)$value
    return(integration)
  }
  cdf <- mapply(cumulative, q, a = mu, b = sigma)
  if(lower.tail==FALSE) cdf <- 1-cdf
  if(log.p==TRUE) cdf <- log(cdf)
  cdf
}
#----------------------------------------------------------------------------------------
# funcao quantilica da distribuicao BS
qBS <- function(p, mu=1, sigma=1, lower.tail = TRUE, log.p = FALSE){
  if (any(mu <= 0)) stop(paste("mu must be positive", "\n", ""))
  if (any(sigma <= 0)) stop(paste("sigma must be positive", "\n", ""))
  if (log.p==TRUE) p <- log(p)
  if (lower.tail==FALSE) p <- 1-p
  if (any(p < 0)|any(p > 1)) stop(paste("p must be between 0 and 1", "\n", ""))
  q <- mu*(sigma*qnorm(p)/2+sqrt((sigma*qnorm(p)/2)^2)+1)^2
  return(q)
}
#----------------------------------------------------------------------------------------
# gerador de numeros aleatorios da distribuicao BS
rBS <- function(n, mu=1, sigma=1){
  if (any(mu <= 0)) stop(paste("mu must be positive", "\n", ""))
  if (any(sigma <= 0)) stop(paste("sigma must be positive", "\n", ""))
  if (any(n <= 0)) stop(paste("n must be a positive integer", "\n", ""))
  n <- ceiling(n)
  p <- runif(n)
  r <- qBS(p,mu=mu,sigma=sigma)
  r
}
#----------------------------------------------------------
```

```{r}
#| label: linear-fit

linear_model <- gamlss(time ~ temperature + puncture + time_under_hydration,
                     data = castor,
                     family = BS)
summary(linear_model)
```

# Fitting a Quantile Regression Model based on the Birnbaum-Saunders Distribution

```{r}
#| label: qr-bs-function

#revised function by T. Nonato
#authors: L. Sanchez, V. Leiva 
#source: https://doi.org/10.1002/asmb.2556

bsreg.fit<-function(x, y, link = "log") {
  n<-NROW(x)
  p<-NCOL(x)
  linkobj<-make.link(link)
  linkfun<-linkobj$linkfun
  linkinv<-linkobj$linkinv
  Q.eta<-linkobj$mu.eta
  ystar<-linkfun(y)
  beta<-ginv(t(x) %*% x) %*% t(x) %*% ystar

  xbar<-mean(y)
  vart<-(n/(n-1))*var(y)
  r<-vart / xbar^2
  alphai<-sqrt((2*r-2+2*sqrt(1+3*r))/(5-r))

  if (is.nan(alphai) || is.na(alphai)) { #MUDANÇA
    s1<-mean(y)
    r1<-1/mean(1/y)
    alphai<-sqrt(2*sqrt(s1/r1)-2)
  }

  start<-c(as.vector(beta), alphai) #MUDANÇA

  # função de verossimilhança (log-like)
  fr<-function(vp) {
    betab<-vp[1:p]
    eta<-as.vector(x %*% betab)
    Q<-linkinv(eta)
    alphab<-vp[p+1]    #MUDANÇA: índice corrigido, garantir escalar 
    q<-0.5
    zq<-qnorm(q, mean = 0, sd = 1)
    gma_alphab<-alphab * zq + sqrt(alphab^2 * zq^2 + 4)
    vt<-y
    sum(-0.5*log(8*pi*vt) - log(alphab) - log(gma_alphab) - 0.5*log(Q) +
        log(gma_alphab^2/2 + 2*Q/vt) -
        (2*Q/(alphab^2*gma_alphab^2*vt))*(vt*gma_alphab^2/(4*Q) - 1)^2)
  }

  # função gradiente: retorna um vetor NUMÉRICO de comprimento p+1
  grr<-function(vp) {
    betab<-vp[1:p]
    eta<-as.vector(x %*% betab)
    Q<-linkinv(eta)
    alphab<-vp[p+1]   # MUDANÇA: garantir escalar
    q<-0.5
    zq<-qnorm(q)
    gma_alphab<-alphab * zq + sqrt(alphab^2 * zq^2 + 4)
    # derivadas auxiliares
    gma_alphabp<-zq + zq^2 * alphab * (1 / sqrt(alphab^2 * zq^2 + 4))
    vt<-y
    z<--0.5*(1/Q) - 2*(1/(alphab^2 * gma_alphab^2 * vt)) +
         gma_alphab^2 * vt * (1/(8 * alphab^2 * Q^2)) +
         4*(1/(vt * gma_alphab^2 + 4*Q))

    b<--(gma_alphab + alphab * gma_alphabp) * (1/(alphab * gma_alphab)) +
         2*vt * gma_alphab * gma_alphabp * (1/(vt * gma_alphab^2 + 4*Q)) -
         (gma_alphab * gma_alphabp * alphab - gma_alphab^2) * vt * (1/(4*Q*alphab^3)) -
         2*(1/(alphab^3)) +
         4*Q*(gma_alphab + alphab * gma_alphabp) * (1/(alphab^3 * gma_alphab^3 * vt))

    # MUDANÇA
    # gradiente em relação a beta (p x 1)
    grad_beta<-as.vector(t(x) %*% (Q.eta(eta) * z))
    # gradiente em relação a alpha (escala)
    grad_alpha<-sum(b)
    
    # retornar UM VETOR numérico (p+1)
    c(grad_beta, grad_alpha)
  }

  A<-matrix(c(rep(0,p),1),1,p+1)
  B<-0

  opt<-maxLik::maxBFGS(fn = fr, grad = grr, start = start,
                         constraints = list(ineqA = A, ineqB = B))

  # MUDANÇA: inspeção para debug

  if (!is.null(opt$code) && opt$code > 0) warning("optimization failed to converge (opt$code > 0)")
  if (!is.null(opt$convergence) && opt$convergence != 0) warning("optimizer signaled non-zero convergence code")

  estimates<-opt$estimate

  # MUDANÇA: garantir que log.lik.est é numérico (NA se não disponível)
  log.lik.est<-if (!is.null(opt$maximum)) opt$maximum else NA

  beta<-as.vector(estimates[1:p])
  eta<-as.vector(x %*% beta)
  Q<-linkinv(eta)
  alpha<-estimates[p+1]
  q<-0.5
  zq<-qnorm(q, mean = 0, sd = 1)

  aux<-matrix(1, ncol = 1L, nrow = n)

  gma_alpha<-alpha * zq + sqrt(alpha^2 * zq^2+4) 
  gma_alphap<-zq+alpha*zq^2*(1/sqrt(alpha^2*zq^2+4))
  gma_alphapp<-4*zq^2*(1/sqrt(alpha^2*zq^2+4)^3)

  par_alpha<-alpha
  par_beta <-4*Q/gma_alpha^2

  Acal<-((2*gma_alphap+alpha*gma_alphapp)*(alpha*gma_alpha)-(gma_alpha+alpha*gma_alphap)^2)/
          (alpha^2*gma_alpha^2)
  Bcal<-8*Q*(gma_alphap^2+gma_alpha*gma_alphapp)
  Ccal<-(1/(4*Q*alpha^4))*(alpha^2*gma_alphap^2+alpha^2*gma_alpha*gma_alphapp-alpha*gma_alpha*gma_alphap-
          3*gma_alpha*gma_alphap*alpha+3*gma_alpha^3)
  Dcal<-4*Q*((2*gma_alphap+alpha*gma_alphapp)*alpha*gma_alpha-3*(gma_alpha+alpha*gma_alphap)^2)/
          (alpha^4*gma_alpha^4)
  
  if(link == "log"){
      a<-Q
      h1<-Q^2
      h2<--1/(Q^2*(log(Q)^3))}
  
  if(link == "identity"){
      a<-rep(1,n)
      h1<-1
      h2<-0}
  
  if(link == "sqrt"){
      a<-2*sqrt(Q)
      h1<-4*Q
      h2<--1/(4*Q^3)}
    
    integ.f2<-c()
    integ.f3<-c()
    integ.f4<-c()
    integ.f5<-c()

  f2<-function(u,j){
      return((u/(u*gma_alpha^2+4*Q[j]))^2*dbisa(u, par_beta[j], par_alpha))}
    
  f3<-function(u,j){
      return((u/(u*gma_alpha^2+4*Q[j])^2)*dbisa(u, par_beta[j], par_alpha))}
    
  f4<-function(u,j){
      return((1/(u*gma_alpha^2+4*Q[j])^2)*dbisa(u, par_beta[j], par_alpha))}
    
  f5<-function(u,j){
    return((1/(u*gma_alpha^2+4*Q[j]))*dbisa(u, par_beta[j], par_alpha))}

  # MUDANÇA: tenta integrar; se der erro, retorna NA ou 0
  safe_integrate <- function(fun, j, lower = 1e-6, upper = 1000) {
    val <- tryCatch(
      integrate(fun, lower = lower, upper = upper, j = j)$value,
      error = function(e) NA_real_)
    if (is.na(val) || is.infinite(val)) val <- 0
    return(val)}
    
  for (i in seq_len(n)) {
    integ.f2[i] <- safe_integrate(f2, i)
    integ.f3[i] <- safe_integrate(f3, i)
    integ.f4[i] <- safe_integrate(f4, i)
    integ.f5[i] <- safe_integrate(f5, i)
  }
    
  AIC <- (-2 * log.lik.est + 2 * (p+1))
  AICc<- AIC + (2 * (p+1) * ((p+1) + 1)) / (n - (p+1) - 1)
  BIC <- (-2 * log.lik.est + log(n) * (p+1))

  v<-(-1/(2*Q^2)+16*integ.f4 + (1/(alpha^2*Q^2))*(1+alpha^2/2))*h1-
      (1/(2*Q)+(1/(2*alpha^2*Q))*(1+alpha^2/2)-4*integ.f5)*h2
    
  s<-8*gma_alpha*gma_alphap*integ.f3 - 
      ((gma_alpha * gma_alphap * alpha- gma_alpha^2)/(alpha^3*gma_alpha^2*Q^2))*(1+alpha^2/2)-
      ((gma_alpha +alpha* gma_alphap)/(alpha^3*gma_alpha *Q))*(1+alpha^2/2)
    
  u<-Acal-Bcal*integ.f3 -2*(gma_alpha^3*gma_alphapp-gma_alpha^2*gma_alphap^2)^2*
      integ.f2 + Ccal*(4*Q/gma_alpha^2)*(1+alpha^2/2)-6/alpha^4-
      Dcal*(gma_alpha^2/(4*Q))*(1+alpha^2/2)
  
  kbb<-t(x)%*%diag(as.vector(v))%*%x
  kaa<-sum(diag(as.vector(u)))
  kba<-t(x)%*%diag(as.vector(a))%*%s
  
  Diag<-function(A){
    diag.A<-vector()
    for(t in 1:ncol(A)){
      diag.A[t]=A[t,t]
    }
    return(as.vector(diag.A))
  }
  
  fisher<-cbind(rbind(kbb, t(kba)), rbind(kba, kaa))
  se  <-sqrt(Diag(solve(fisher)))
  
  hess<-as.matrix(opt$hessian)

  if(p == 1) {
    var.explic<-x
  }  else {
            var.explic<-x[,-1]
          }

  zstatbeta<-beta / se[1:p]
  zstatalpha <-alpha / se[p+1] #MUDANÇA: índice
  pvalorbeta<-2 * pnorm(abs(zstatbeta), lower.tail = F)
  pvaloralpha<-2 * pnorm(abs(zstatalpha), lower.tail = F)

  names(beta)<-colnames(x)

  rval<-list(coefficients=list(beta = beta, alpha = alpha),
               fitted.values.Q=structure(Q, .Names = names(y)),
               n = n, p = p, q = q, eta = eta,
               X = x, y = y,
               # MUDANÇA: garantir hessian é matriz ou NULL
               Hessian=if(!is.null(opt$hessian)) as.matrix(opt$hessian) else NULL,
               matrix.expected.Fisher = fisher,
               loglik = log.lik.est,
               link = list(quantile = linkobj),
               # MUDANÇA: garantir campo 'converged' é TRUE/FALSE/NA
               converged=if(!is.null(opt$code)) (opt$code==0) else NA,
               information.criterions = list(aic = AIC,bic = BIC,aicc=AICc), 
               se = se, zstat = list(beta = zstatbeta, alpha = zstatalpha),
               pvalor = list(beta = pvalorbeta, alpha = pvaloralpha))

  return(rval)
}
```

```{r}
#| label: summary-bsreg
summary.bsreg.fit <- function(model, ...) {
  cat("Call: bsreg.fit\n\n")
  coefs <- cbind(
    Estimate = c(model$coefficients$beta, model$coefficients$alpha),
    "Std. Error" = model$se,
    "z value" = c(model$zstat$beta, model$zstat$alpha),
    "Pr(>|z|)" = c(model$pvalor$beta, model$pvalor$alpha)
  )
  rownames(coefs) <- c(names(model$coefficients$beta), "alpha")
  printCoefmat(coefs)
  cat("\nLog-likelihood:", round(model$loglik, 3), "\n")
  cat("AIC:", round(model$information.criterions$aic, 2),
      " BIC:", round(model$information.criterions$bic, 2),
      " AICc:", round(model$information.criterions$aicc, 2), "\n")
}

```

```{r}
#| label: qr-bs-model

quantile_model <- bsreg.fit(
  x = model.matrix(~ temperature + puncture + time_under_hydration, data = castor),
  y = castor$time,
  link = "log")

summary.bsreg.fit(quantile_model)
```




# Pre-project presentation structure

- introdução
- rev. bibliografica
- modelo
- aplicação

# Modelo Quantílico

Seja $T_i \sim \mathrm{BS}(\alpha, Q_i)$, onde
$$
h(Q_i) = \eta_i = \mathbf{x}_i^\top \boldsymbol{\beta}, \quad i = 1, \ldots, n,
$$
tal que $Q_i = h^{-1}(\mathbf{x}_i^\top \boldsymbol{\beta})$, onde $\boldsymbol{\beta} = (\beta_0, \beta_1, \ldots, \beta_{p-1})^\top$, para $p < n$, é um vetor de parâmetros de regressão desconhecidos a serem estimados, e $\mathbf{x}_i^\top = (1, x_{i1}, \ldots, x_{i(p-1)})$ representa os valores das $p$ covariáveis.

# Modelo GAMLSS

Seja $Y \sim D(\boldsymbol{\theta}_k)$, onde $D$ é uma distribuição de probabilidade e $\boldsymbol{\theta}_k = (\theta_1, \ldots, \theta_p)^\top$.

$$
g_k(\theta_k) = \eta_k = X_k \boldsymbol{\beta}_k + \sum_{j=1}^{J_k} s_{jk}(x_{jk}),
$$

onde $g_k(\cdot)$, $k = 1, \ldots, p$, é uma função de ligação que relaciona o parâmetro $\theta_k$ com seu preditor $\eta_k$, $X_k$ é uma matriz de delineamento conhecida, $\boldsymbol{\beta}_k^\top = (\beta_{1k}, \ldots, \beta_{J_k^0 k})$ é um vetor de parâmetros de comprimento $J_k^0$ e $s_{jk}$ é uma função não paramétrica (por exemplo, um P-spline) de uma variável explicativa $x_{jk}$.
